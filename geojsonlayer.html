<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <script src="https://unpkg.com/deck.gl@^9.0.0/dist.min.js"></script>
    <script src='https://unpkg.com/maplibre-gl@3.0.0/dist/maplibre-gl.js'></script>
    <link href='https://unpkg.com/maplibre-gl@3.0.0/dist/maplibre-gl.css' rel='stylesheet' />
    <style type="text/css">
    body {margin: 0; padding: 0;}
    #map {width: 100vw; height: 100vh;}
    .map-overlay {
        position: absolute;
        width: 170px;
        top: 0;
        left: 0;
        padding: 0px;
        background-color: #fff;
    }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <div class="map-overlay top">
        <div class="map-overlay-inner">
            <input id="slider" type="range" min="0" value="0" />
        </div>
        <div class="map-overlay-inner">
            <button id="pauseButton">&#x23f8;</button>
            <button id="playButton">&#x25b6;</button>
        </div>
        <div id="label"></div>
    </div>
    <script type="text/javascript">
const urlParams = new URLSearchParams(document.location.search);
let latlon = [35.7574, 139.7293];
let latlonParam = urlParams.get('latlon');
if (latlonParam) {
    latlon = latlonParam.split(',').map(Number);
}
let zoom = +urlParams.get('zoom') || 11;
let pitch = urlParams.has('pitch') ? +urlParams.get('pitch') : 0; // allow 0
let interval = +urlParams.get('intervalMs') || 1000;
const radiuskeyParam = urlParams.get('radiuskey');
let mapStyle = urlParams.get('mapStyle') || 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json';

const jsonurl = urlParams.get('jsonurl') || 'https://deton.github.io/HeatMapWithTime/sampledata/15-PT30M-capacity.geojson';
fetch(jsonurl).then(res => res.json()).then(json => loadData(json)).catch(console.error);

const slider = document.getElementById("slider");
const pauseButton = document.getElementById("pauseButton");
const playButton = document.getElementById("playButton");

pauseButton.onclick = stopTimer;
let timerId;
function stopTimer() {
    clearInterval(timerId);
}

const deckgl = new deck.DeckGL({
    container: 'map',
    mapStyle: mapStyle,
    initialViewState: {
        longitude: latlon[1],
        latitude: latlon[0],
        zoom: zoom,
        pitch: pitch,
    },
    controller: true,
    getTooltip: ({object}) => object && object.properties.tooltip,
});

let radiuskey = radiuskeyParam;
let time = 0;
function loadData(json) {
    stopTimer();

    if (!latlonParam) {
        const lonlat = json.features[0].geometry.coordinates; // TODO: calc bounds
        deckgl.setProps({
            initialViewState: {
                longitude: lonlat[0],
                latitude: lonlat[1],
                zoom: zoom,
                pitch: pitch,
            },
        });
    }
    const valuekeys = json.valuekeys || [];
    if (radiuskey === null && valuekeys.length > 0) {
        radiuskey = valuekeys[0];
    }

    const [timeMin, timeMax, tick] = timeinterval(json.features);
    time = timeMin;

    slider.min = String(timeMin);
    slider.max = String(timeMax);
    slider.oninput = onSliderValueChange;
    function onSliderValueChange(ev) {
        time = Number(ev.target.value);
        updateSliderLabel(time, json);
        renderLayer(json);
    }
    function updateSliderLabel(time, json) {
        const timeIdx = getTimeIdx(json.features[0], time);
        const label = json.features[0].properties.times.at(timeIdx);
        document.getElementById("label").textContent = label;
    }

    playButton.onclick = startTimer;
    function startTimer() {
        stopTimer();
        timerId = setInterval(() => {
            time += tick;
            slider.value = String(time);
            updateSliderLabel(time, json);
            if (time >= timeMax) {
                stopTimer();
            } else {
                renderLayer(json);
            }
        }, interval);
    }
    startTimer();
}

function timeinterval(features) {
    let min = +Infinity;
    let max = 0;
    let mindiff = +Infinity;
    features.forEach(feature => {
        const times = feature.properties.times;
        if (!times) {
            return;
        }
        const millis = times.map(Date.parse);
        feature._featureTimes = millis; // XXX: like Leaflet.TimeDimension
        min = Math.min(min, ...millis);
        max = Math.max(max, ...millis);
        // TODO: diff on all times in all features
        mindiff = millis.reduce((accum, cur, idx) => {
            return Math.min(accum, cur - millis[idx - 1]);
        });
    });
    return [min, max, mindiff];
}

function renderLayer(json) {
    deckgl.setProps({
        layers: new deck.GeoJsonLayer({
            id: 'GeoJsonLayer',
            data: json,
            pointType: 'circle',
            getPointRadius: f => getPointRadiusAtTime(f, time),
            getFillColor: f => getColor(f, true),
            getLineColor: f => getColor(f, false),
            pointRadiusScale: 10,
            pointRadiusMinPixesl: 10,
            updateTriggers: {
                getPointRadius: time,
            },
        }),
    });
}

function getColor(feature, isfill) {
    const color = feature.properties.iconstyle && feature.properties.iconstyle.color;
    if (!color) {
        return [255, 0, 0, isfill ? 153 : 255];
    }
    const rgb = color.slice(1).match(/.{2}/g).map(hex => parseInt(hex, 16));
    return [...rgb, isfill ? 153 : 255];
}

function getPointRadiusAtTime(feature, time) {
    const idx = getTimeIdx(feature, time);
    const radius = feature.properties[radiuskey].at(idx) + 2;
    return radius;
}

function getTimeIdx(feature, time) {
    const featureTimes = feature._featureTimes;
    if (!featureTimes) {
        return -1;
    }
    const idx = featureTimes.findIndex((t, i) => {
        const tnext = featureTimes.at(i + 1);
        return (time >= t && (tnext === undefined || time < tnext));
    });
    return idx;
}
    </script>
</body>
</html>
