<!DOCTYPE html>
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<title>TimestampedGeoJson</title>
<style>html, body {width: 100%;height: 100%;margin: 0;padding: 0;}</style>
<style>#map {position:absolute;top:0;bottom:0;right:0;left:0;}</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
<meta name="viewport" content="width=device-width,
    initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<style>
#toolbar {
    position: absolute;
    top: 5px;
    left: 60px;
    z-index: 1000;
}
.leaflet-popup-content {
  width: 400px;
  height: 100%;
}
</style>
<script src="https://cdn.jsdelivr.net/npm/iso8601-js-period@0.2.1/iso8601.min.js"></script>
<script src="https://deton.github.io/Leaflet.TimeDimension/dist/leaflet.timedimension.min.js"></script>
<!--XXX: some fixes not released yet. script src="https://cdn.jsdelivr.net/npm/leaflet-timedimension@1.1.1/dist/leaflet.timedimension.min.js"></script>-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.18.1/moment.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-timedimension@1.1.1/dist/leaflet.timedimension.control.css"/>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
// https://github.com/python-visualization/folium/blob/553a33981fa29a9d4ce6c426563749188906610f/folium/plugins/timestamped_geo_json.py#L84

L.Control.TimeDimensionCustom = L.Control.TimeDimension.extend({
    _getDisplayDateFormat: function(date){
        var newdate = new moment(date);
        //console.log(newdate)
        return newdate.format("YYYY-MM-DD HH:mm");
    }
});
</script>
</head>
<body>
<div id="map"></div>
<div id="toolbar" class="leaflet-control">
    Import data: <input type="file" id="fileElem" accept=".geojson" />
</div>
</body>
<script>
var map = L.map('map');
L.tileLayer('https://tile.openstreetmap.jp/styles/osm-bright/{z}/{x}/{y}.png', {
    attribution: '<a href="https://www.openmaptiles.org/" target="_blank">&copy; OpenMapTiles</a> <a href="https://www.openstreetmap.org/copyright" target="_blank">&copy; OpenStreetMap contributors</a>'
}).addTo(map);
const layerControl = L.control.layers(null, null, {
    collapsed: false,
}).addTo(map);

const urlParams = new URLSearchParams(document.location.search);
let latlon = urlParams.get('latlon');
if (latlon) {
    latlon = latlon.split(',').map(Number);
    let zoom = +urlParams.get('zoom') || 13;
    map.setView(latlon, zoom);
}
const jsonurl = urlParams.get('jsonurl');
if (jsonurl) {
  fetch(jsonurl).then(res => res.json()).then(json => loadData(json)).catch(console.error);
}

const fileInput = document.getElementById("fileElem");
fileElem.addEventListener("change", () => {
    const [file] = fileElem.files;
    if (file) {
        file.text().then(text => {
            loadData(JSON.parse(text));
        }).catch(console.error);
    }
    //fileElem.value = '';
});

let tdControl;
let iconDLayer;

function loadData(data) {
    if (tdControl) {
        tdControl._player.stop();
        tdControl.remove();
    }
    map.timeDimension = L.timeDimension({
        duration: 'PT30M',
    });

    tdControl = new L.Control.TimeDimensionCustom({
        autoPlay: true,
        loopButton: true,
        minSpeed: 1,
        speedStep: 0.5,
        playerOptions: {
            loop: true,
            startOver: true,
        },
    });
    map.addControl(tdControl);

    // keep original times not to be overridden by millis array by L.TimeDimension.
    data.features.forEach(feature => {
        feature.properties.origTimes = [...feature.properties.times];
    });

    if (iconDLayer) {
        iconDLayer.remove();
    }
    // TODO: make geojson layers for each system_id to control toggle display
    const iconLayer = L.geoJson(data, {
        pointToLayer,
        onEachFeature: (feature, layer) => {
            bindPopupTooltip(feature, layer);
            /*
            // convert string times to number [ms].
            // cf. L.TimeDimension.Layer.GeoJson._getFeatureTimes()
            //feature.properties.origTimes = [...feature.properties.times]; // XXX: too late
            feature.properties.times = feature.properties.times.map(time => {
                if (typeof time == 'string' || time instanceof String) {
                    return Date.parse(time.trim());
                }
                return time;
            });
            */
        }
    });
    if (!latlon) {
        map.fitBounds(iconLayer.getBounds());
    }
    // iconD layer to show the change of the icon
    iconDLayer = L.timeDimension.layer.geoJson(iconLayer, {
        updateTimeDimension: true,
        addlastPoint: true,
        updateTimeDimensionMode: 'replace',
    });
    iconDLayer.addTo(map);
    //layerControl.addOverlay(iconDLayer, seriesId);
}

function pointToLayer(feature, latLng) {
    let iconstyle = feature.properties.iconstyle;
    if (feature.properties.icon == 'marker') {
        if (iconstyle) {
            return new L.Marker(latLng, {
                icon: L.icon(iconstyle)
            });
        }
        return new L.Marker(latLng);
    }
    if (feature.properties.icon == 'circle') {
        if (iconstyle) {
            const cur = map.timeDimension.getCurrentTime();
            let idx = -1;
            if (feature.properties.times) { // [Number]
                idx = feature.properties.times.indexOf(cur);
            }
            return new L.circleMarker(latLng, {
                ...iconstyle,
                radius: feature.properties.bikes.at(idx) + 2,
                //radius: Math.log2(1 + feature.properties.bikes.at(idx)) + 2,
            });
        }
        return new L.circleMarker(latLng);
    }
    return new L.Marker(latLng);
}

function bindPopupTooltip(feature, layer) {
    if (feature.properties.tooltip) {
        layer.bindTooltip(feature.properties.tooltip);
    }
    if (!(feature.properties.origTimes && feature.properties.bikes)) {
        return;
    }
    layer.bindPopup((layer) => {
        console.log(feature.properties);
        const canvas = document.createElement('canvas');
        new Chart(canvas, {
            type: 'line',
            data: {
                labels: feature.properties.origTimes.map(s => s.substring(11)),
                datasets: [{
                    label: 'bikes_available',
                    data: feature.properties.bikes,
                    borderColor: 'red',
                }, {
                    label: 'docks_available',
                    data: feature.properties.docks,
                    borderColor: 'blue',
                }]
            },
            options: {
                plugins: {
                    title: {
                        text: feature.properties.id,
                        display: true,
                    },
                }
            }
        });
        return canvas;
    }, {
        autoClose: false,
        closeOnClick: false,
        maxWidth: 400,
        maxHeight: 300,
    });
}
</script>
</html>
